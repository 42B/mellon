ORM Query Helpers
==================

It is a common activity to query Mellon ORM data.  this package contains some
components that streamline common query operations.  These operations are based
on SQL LEFT OUTER JOIN logic.  The components allow for proper manipulation
of the left-most table (all of the left-most table contents is available for
the query, while tables further right will be restricted based on bridged
foreign key relationships).

To help understand, consider the following list as related tables

a, b, c, d, e

assume that b has a foreign key to a, c has a foreign key to be, and so forth...
searching for a's based on filters related to b-e is straight forward

SELECT a,b,c,d,e FROM a LEFT OUTER JOIN b LEFT OUTER JOIN c ... WHERE b.1 != 'something'

But if you wanted to search for c's based on filters in other tables, then

SELECT c,b,a,d,e FROM c LEFT OUTER JOIN b ... WHERE a.1 == 'something'

The components in this package help to streamline this kind of activity.


Model Relationship Graph
-------------------------
To effectively query the Mellon ORM data, first ORM table relationships
must be defined.  This identifies the one->many->many->... for each table.
The base orm package contains the following tables:

 - authorization_contexts       (ORM Model: AuthorizationContext)
 - mellon_files                 (ORM Model: MellonFile)
 - mellon_file_access_contexts  (ORM Model: MellonFileAccessContext)
 - snippets                     (ORM Model: Snippet)
 - secrets                      (ORM Model: Secret)
 - secret_discovery_dates       (ORM Model: SecretDiscoveryDate)

Each of these tables contains a foreign key relationship with at least one
other table in the list (see models.py for more details).  This top-down
order shown above is important as tables have direct or indirect relationships
with all tables listed higher.

The query package provides the IORMRelatedModelsAdder interface to help manage this
structure via the ORM models.  Mostly this is important to understand if you
plan to add extra ORM models on top of this list and then need to be able to
search that data in the method described above (e.g. LEFT OUTER JOIN).

an empty IORMRelatedModelsAdder provider can be created via a component factory
>>> from zope import component
>>> rel_manager = component.createObject(u"mellon_plugin.reporter.sqlalchemy.orm.query.orm_related_models_adder")

We can add a couple relationships easy enough.  Model relationship are added
as sequences.  These are added into the manager as a graph with by-directional
edges for each adjacent sequence entry.
>>> from mellon_plugin.reporter.sqlalchemy.orm import models
>>> rel_manager.add_sequence([models.Snippet, models.Secret])

Once the graph is populated, we can enumerate it in BFS form via the
flattened() call.  We have to indicate where the BFS traversal will start.  In
this example, we start from Snippet.
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.Snippet)))
['Snippet', 'Secret']

We could just as easy start from Secret
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.Secret)))
['Secret', 'Snippet']

You can add isolated nodes without any harm
>>> rel_manager.add_sequence([models.MellonFile])
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.Secret)))
['Secret', 'Snippet']
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.MellonFile)))
['MellonFile']

You can add edges to those nodes easy enough
>>> rel_manager.add_sequence([models.MellonFile, models.Snippet])
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.MellonFile)))
['MellonFile', 'Snippet', 'Secret']


The package offers a few pre-made utilities for common graphs.

A core stack
>>> rel_manager = component.createObject( 
... 				u"mellon_plugin.reporter.sqlalchemy.orm.query.mellon_core_related_models")
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.MellonFile)))
['MellonFile', 'Snippet', 'Secret']

A Stack that includes the authorization context
>>> rel_manager = component.createObject(
... 				u"mellon_plugin.reporter.sqlalchemy.orm.query.mellon_auth_context_related_models")
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.AuthorizationContext)))
['AuthorizationContext', 'MellonFileAccessContext', 'MellonFile', 'Snippet', 'Secret']

A full stack that includes the discovery dates
>>> rel_manager = component.createObject(
... 				u"mellon_plugin.reporter.sqlalchemy.orm.query.mellon_all_related_models")
>>> list(map(lambda x: x.__name__, rel_manager.flattened(models.AuthorizationContext)))
['AuthorizationContext', 'MellonFileAccessContext', 'MellonFile', 'Snippet', 'Secret', 'SecretDiscoveryDate']


Model Query & Result Utility
-----------------------------
Now that the model relationships have been define, we can move into creating
database queries and getting results.

Let's consider a simple example with the core models MellonFile, Snippet, 
and Secret.  Here's how you could get a SQLAlchemy query object that would
return all Secrets and their related Snippet and File:

first, get the core model stack
>>> rel_manager = component.createObject(
... 				u"mellon_plugin.reporter.sqlalchemy.orm.query.mellon_core_related_models")

Now we can get a query object via a component factory.  q is a ISAQuery 
provider, which means it is a SQLAlchemy Query object.  In this case, q is also
a ISAOuterJoinQuery provider allowing the kind of filtering we desire.  Notice
how we pass in the model sequence based on the flattened() call (which 
identifies the required left-most model).
>>> q = component.createObject(u"mellon_plugin.reporter.sqlalchemy.orm.query.outer_joined_query",
... 						rel_manager.flattened(models.MellonFile))

Now that our query is prepared, we can execute it and examine the results.
Result rows are returned as KeyedTuple objects.  Tuple entries will be ORM
models in the context of this package.  This package provides a convenience 
utility for ISAResultRowModel to extract model results from a row based on a 
given interface.
>>> from mellon_plugin.reporter.sqlalchemy.orm.query import ISAResultRowModel
>>> rrm = component.getUtility(ISAResultRowModel)
>>> from mellon_plugin.reporter.sqlalchemy.orm import ISAMellonFile
>>> mellon_file = rrm.first(ISAMellonFile, q.first()) # get the first row entry that provides ISAMellonFile
>>> ISAMellonFile.providedBy(mellon_file)
True


Model Filter
-------------
The entire purpose of building these components is to allow effective filtering
of queried ORM models.  A recursive data structure  can be used as the basis
for a query filter definition.  The structure follows this paradigm:

{
 'conjunction': 'and',
 'expressions':
    [
     {'attribute':'model.field1', 'condition':'==', 'value':'value1'},
     {'attribute':'model.field2', 'condition':'!=', 'value':'value2'},
     {
      'conjunction': 'or',
      'expressions':
          [
           {'attribute':'model.field3', 'condition':'==', 'value':'value3'},
           {'attribute':'model.field4', 'condition':'is null'}
          ]
     }
    ]
}

WHERE model.field1 == 'value1' AND model.field2 != 'value2' AND (model.field1 == 'value3' OR model.field4 IS NULL)

We'll start by creating a simple filter definition
>>> filter = {
...  'conjunction': 'and',
...  'expressions':
...      [{'attribute':'MellonFile.id', 'condition':'==', 'value':'some_file_name'}]
... }


To use this definition, we need to convert it into ISAModelFilterExpressionGroup
provider.  We have a component factory that will do this for us
>>> expression_group = component.createObject(
... 		u"mellon_plugin.reporter.sqlalchemy.orm.query.filter_expression_group_from_container", filter)

We can adapt ISAModelFilterExpressionGroup into ISAConjunction, which is 
ultimately what is passed into the SQLAlchemy query object's filter method
>>> from mellon_plugin.reporter.sqlalchemy.orm.query import ISAConjunction
>>> q.filter(ISAConjunction(expression_group)).all()
[]
